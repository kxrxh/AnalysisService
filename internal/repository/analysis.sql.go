// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analysis.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAnalysesByUserID = `-- name: CountAnalysesByUserID :one
SELECT COUNT(*)
FROM analysis
WHERE id_user = $1
  AND ($2::TEXT IS NULL OR $2 = '' OR product = $2)
  AND ($3::TEXT IS NULL OR $3 = '' OR CAST(id_analysis AS TEXT) LIKE '%' || $3 || '%')
`

type CountAnalysesByUserIDParams struct {
	IDUser     pgtype.Text `json:"id_user"`
	Product    string      `json:"product"`
	IDAnalysis string      `json:"id_analysis"`
}

func (q *Queries) CountAnalysesByUserID(ctx context.Context, arg CountAnalysesByUserIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAnalysesByUserID, arg.IDUser, arg.Product, arg.IDAnalysis)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAnalysesByIDs = `-- name: GetAnalysesByIDs :many
SELECT id, date_time, product, color_rhs, id_user, telegram_link, text, file_source, scale_mm_pixel, mass, area, r, g, b, h, s, v, lab_l, lab_a, lab_b, w, l, t, file_output, id_analysis
FROM analysis
WHERE id = ANY($1::int[])
`

func (q *Queries) GetAnalysesByIDs(ctx context.Context, ids []int32) ([]Analysis, error) {
	rows, err := q.db.Query(ctx, getAnalysesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Analysis{}
	for rows.Next() {
		var i Analysis
		if err := rows.Scan(
			&i.ID,
			&i.DateTime,
			&i.Product,
			&i.ColorRhs,
			&i.IDUser,
			&i.TelegramLink,
			&i.Text,
			&i.FileSource,
			&i.ScaleMmPixel,
			&i.Mass,
			&i.Area,
			&i.R,
			&i.G,
			&i.B,
			&i.H,
			&i.S,
			&i.V,
			&i.LabL,
			&i.LabA,
			&i.LabB,
			&i.W,
			&i.L,
			&i.T,
			&i.FileOutput,
			&i.IDAnalysis,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnalysesByUserTelegramIDPagination = `-- name: GetAnalysesByUserTelegramIDPagination :many
SELECT id, date_time, product, color_rhs, id_user, telegram_link, text, file_source, scale_mm_pixel, mass, area, r, g, b, h, s, v, lab_l, lab_a, lab_b, w, l, t, file_output, id_analysis
FROM analysis
WHERE id_user = $1
  AND ($2::TEXT IS NULL OR $2 = '' OR product = $2)
  AND ($3::TEXT IS NULL OR $3 = '' OR CAST(id_analysis AS TEXT) LIKE '%' || $3 || '%')
ORDER BY
    CASE WHEN $4 = 'date_time' AND $5 = 'asc' THEN date_time END ASC,
    CASE WHEN $4 = 'date_time' AND $5 = 'desc' THEN date_time END DESC,
    CASE WHEN $4 = 'id' AND $5 = 'asc' THEN id END ASC,
    CASE WHEN $4 = 'id' AND $5 = 'desc' THEN id END DESC,
    CASE WHEN $4 = 'product' AND $5 = 'asc' THEN product END ASC,
    CASE WHEN $4 = 'product' AND $5 = 'desc' THEN product END DESC
LIMIT $7::int
OFFSET $6::int
`

type GetAnalysesByUserTelegramIDPaginationParams struct {
	IDUser     pgtype.Text `json:"id_user"`
	Product    string      `json:"product"`
	IDAnalysis string      `json:"id_analysis"`
	SortBy     interface{} `json:"sort_by"`
	SortOrder  interface{} `json:"sort_order"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

func (q *Queries) GetAnalysesByUserTelegramIDPagination(ctx context.Context, arg GetAnalysesByUserTelegramIDPaginationParams) ([]Analysis, error) {
	rows, err := q.db.Query(ctx, getAnalysesByUserTelegramIDPagination,
		arg.IDUser,
		arg.Product,
		arg.IDAnalysis,
		arg.SortBy,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Analysis{}
	for rows.Next() {
		var i Analysis
		if err := rows.Scan(
			&i.ID,
			&i.DateTime,
			&i.Product,
			&i.ColorRhs,
			&i.IDUser,
			&i.TelegramLink,
			&i.Text,
			&i.FileSource,
			&i.ScaleMmPixel,
			&i.Mass,
			&i.Area,
			&i.R,
			&i.G,
			&i.B,
			&i.H,
			&i.S,
			&i.V,
			&i.LabL,
			&i.LabA,
			&i.LabB,
			&i.W,
			&i.L,
			&i.T,
			&i.FileOutput,
			&i.IDAnalysis,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnalysisByID = `-- name: GetAnalysisByID :one

SELECT id, date_time, product, color_rhs, id_user, telegram_link, text, file_source, scale_mm_pixel, mass, area, r, g, b, h, s, v, lab_l, lab_a, lab_b, w, l, t, file_output, id_analysis
FROM analysis
WHERE id_analysis = $1
`

// Queries for the analysis table
func (q *Queries) GetAnalysisByID(ctx context.Context, idAnalysis pgtype.Text) (Analysis, error) {
	row := q.db.QueryRow(ctx, getAnalysisByID, idAnalysis)
	var i Analysis
	err := row.Scan(
		&i.ID,
		&i.DateTime,
		&i.Product,
		&i.ColorRhs,
		&i.IDUser,
		&i.TelegramLink,
		&i.Text,
		&i.FileSource,
		&i.ScaleMmPixel,
		&i.Mass,
		&i.Area,
		&i.R,
		&i.G,
		&i.B,
		&i.H,
		&i.S,
		&i.V,
		&i.LabL,
		&i.LabA,
		&i.LabB,
		&i.W,
		&i.L,
		&i.T,
		&i.FileOutput,
		&i.IDAnalysis,
	)
	return i, err
}
